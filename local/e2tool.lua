--[[
   e2factory, the emlix embedded build system

   Copyright (C) 2007-2009 Gordon Hecker <gh@emlix.com>, emlix GmbH
   Copyright (C) 2007-2009 Oskar Schirmer <os@emlix.com>, emlix GmbH
   Copyright (C) 2007-2008 Felix Winkelmann, emlix GmbH
   
   For more information have a look at http://www.e2factory.org

   e2factory is a registered trademark by emlix GmbH.

   This file is part of e2factory, the emlix embedded build system.
   
   e2factory is free software: you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
]]

-- e2tool.lua
--
-- High-level tools used by the build process and basic build operations.


e2tool = e2lib.module("e2tool")

-- store supported config_syntax versions here, the newest one must be listed
-- first, to maintain correct error messages

local config_syntax_compat = {
	buildconfig.E2_SYNTAX,	-- keep this one, it holds the current syntax.
	"2_2_0",
}

-- Information gathering and inquiry
--
--   e2tool.collect_project_info([PATH]) -> INFO
--
--     Collects project-information from the project directory which is computed
--     via e2lib.locate_project_root(PATH). Returns a table with the following
--     entries:

--- info table
-- @name info
-- @class table
-- @field name string: project name
-- @field root string: project root directory
-- @field root_server string: url pointing to the project root
-- @field root_server_name string: name of the root server (".")
-- @field default_repo_server string: name of the default scm repo server
-- @field default_files_server string: name of the default files server
-- @field result_storage (deprecated)
-- @field default_results table: default result list
-- @field sources table: sources
-- @field sources_sorted table: sorted list of sources
-- @field results table: results
-- @field results_sorted table: sorted list of results
-- @field servers table: servers
-- @field licences table: licences keyed by licence names
-- @field licences_sorted table: sorted list of licences
-- @field chroot table: chroot
-- @field chroot_groups table: chroot groups by name
-- @field chroot_groups_sorted table: sorted list of chroot groups
-- @field ghash table: temporary list keeps hashes for chroot groups
-- 			(generated by buildid_chrootgroup())
-- @field build_numbers table: build numbers keyed by result names
-- @field project_location string: project location relative to the servers
-- @field release_id string: release identifiert XXX where do we initialize it?

--- table of sources records, keyed by source names
-- @name sources
-- @class table
-- @field name string: name of the package
-- @field licences table: list of licences
-- @field type string: type of sources ("files", "git", etc)
-- @field server string: server name
-- @field remote string: remote location name
-- @field working string: working directory name
-- @field branch string: branch name
-- @field tag table: table of tag names (strings)
-- @field file table: table of file records (tables)
-- @field fhash string: hash value for this source, for use in buildid 
-- 			calculation
-- @field flist table: array of files
-- 			(deprecated, replaced by file records)

--- file records in the sources table
-- @name source.file
-- @class table
-- @field name string: filename
-- @field server string: server name

--- table of result records, keyed by result names
-- @name results
-- @class table
-- @field name string: name of the result
-- @field sources table of strings: array of source names
-- @field files OBSOLETE table of strings: array of result file names
-- @field depends table of strings: list of dependencies
-- @field chroot table of strings: list of chroot groups to use
-- @field collect_project bool: collect the project structure into this result?
-- @field collect_project_default_result string: which result shall be 
-- 				collected, including recursive dependencies?
-- @field collect_project_results table: sorted list of results to be
-- 								collected
-- @field collect_project_sources table: sorted list of sources to be
-- 								collected
-- @field collect_project_chroot_groups table: sorted list of chroot groups
-- 							to be collected
-- @field collect_project_licences table: sorted list of licences to be
-- 								collected
-- @field export bool: export to the result with collect_project enabled?
-- @field selected bool: select for build?
-- @field force_rebuild bool: force rebuild?
-- @field phash string: partial buildid for this result. (Without taking
-- 			dependencies into account.)
-- @field bhash string: buildid for this result (Taking dependencies into
-- 			account.)
-- @field build_mode table: build mode policy object

--- table of server records, keyed by server name
-- @name servers
-- @class table
-- @field name string: server name
-- @field path (deprecated)
-- @field url string: server url
-- @field cachable bool: cachable flag
-- @field cache bool: cache enable flag
-- @field directory string: dirname where the config and build-script reside

--- table of chroot configuration
-- @name chroot
-- @class table
-- @field groups table: chroot group table

--- chroot group table
-- @name chroot group table
-- @class table
-- @field name string: group name
-- @field server string: server name
-- @field files table: array of file names

--- env - environment table from "proj/env"
-- @name env
-- @class table

--
--   e2tool.load_user_config(INFO, PATH, DEST, INDEX, VAR) --> OK?
--
--     from the file at PATH, load a configuration named VAR.
--     the resulting data is fixated and stored as DEST[INDEX].
--     fixating is done by the local function tablefixate,
--     which keeps a list of all array member names in the specific
--     array member ".fix". furthermore, the type of the configuration
--     is memorized at ".e2". when storing the configuration back
--     to permanent memory, only those table entries which are listed
--     in the ".fix" array will be stored to the configuration file.
--     storing details are described with e2tool.save_user_config below.

function e2tool.opendebuglogfile(info)
  e2lib.mkdir(info.root .. "/log", "-p")
  e2lib.debuglogfile = luafile.open(info.root .. "/log/debug.log", "w")
end

--- load user configuration file
-- @param info
-- @param path string: path to file
-- @param dest
-- @param index
-- @param var
-- @return bool
-- @return an error object on failure
function e2tool.load_user_config(info, path, dest, index, var)
  local rc, re
  local e = new_error("loading configuration failed")
  e2lib.log(3, "loading " .. path)
  if not e2util.exists(path) then
    return false, e:append("file does not exist: %s", path)
  end
  local function func(table)
    dest[index] = table
  end
  local rc, re = e2lib.dofile_protected(path, { [var] = func, env = info.env, string=string })
  if not rc then
    return false, e:cat(re)
  end
  if not dest[ index ] then
    return false, e:append("empty or invalid configuration: %s", path)
  end
  return true
end

--- config item
-- @class table
-- @class config_item
-- @field data table: config data
-- @field type string: config type
-- @field filename string: config file name

--- load config file and return a list of config item tables
-- @param path string: file to load
-- @param type list of strings: allowed config types
-- @return list of config items
-- @return an error object on failure
function e2tool.load_user_config2(info, path, types)
  local e = new_error("loading configuration file failed")
  local rc, re
  local list = {}

  -- the list of config types
  local f = {}
  f.e2source = function(data)
    local t = {}
    t.data = data
    t.type = "sources"
    t.filename = path
    table.insert(list, t)
  end
  f.e2result = function(data)
    local t = {}
    t.data = data
    t.type = "result"
    t.filename = path
    table.insert(list, t)
  end
  f.e2project = function(data)
    local t = {}
    t.data = data
    t.type = "project"
    t.filename = path
    table.insert(list, t)
  end
  f.e2chroot = function(data)
    local t = {}
    t.data = data
    t.type = "chroot"
    t.filename = path
    table.insert(list, t)
  end
  f.e2env = function(data)
    local t = {}
    t.data = data
    t.type = "env"
    t.filename = path
    table.insert(list, t)
  end

  local g = {}			-- compose the environment for the config file
  g.env = info.env			-- env 
  g.string = string			-- string
  for _,type in ipairs(types) do
    g[type] = f[type]			-- and some config functions
  end

  rc, re = e2lib.dofile2(path, g)
  if not rc then
    return nil, e:cat(re)
  end
  return list, nil
end

function e2tool.collect_project_info(path)
  local rc, re
  local e = new_error("reading project configuration")

  local info = {}

  -- set the umask value to be used in chroot
  info.chroot_umask = 18   -- 0022 octal
  e2tool.init_umask(info)

  info.root, re = e2lib.locate_project_root(path)
  if not info.root then
    return false, e:append("you are not located in a project directory")
  end
  rc, re = e2tool.lcd(info, ".")
  if not rc then
    return false, e:cat(re)
  end

  -- check for configuration compatibility
  info.config_syntax_compat = config_syntax_compat
  info.config_syntax_file = ".e2/syntax"
  rc, re = e2tool.check_config_syntax_compat(info)
  if not rc then
    local s = [[
Your configuration syntax is incompatible with this tool version.
Please read the configuration Changelog, update your project configuration
and finally insert the new configuration syntax version into %s

The newest configuration syntax supported by the tools is %s.
]]
    e2lib.logf(2, s, info.config_syntax_file, info.config_syntax_compat[1])
    e2lib.finish(1)
  end

  -- try to get project specific config file paht
  local config_file_config = string.format("%s/.e2/e2config", info.root)
  local config_file = e2lib.read_line(config_file_config)
  -- don't care if this succeeds, the parameter is optional.

  local rc, re = e2lib.read_global_config(config_file)
  if not rc then
    return false, e:cat(re)
  end

  info.local_template_path = string.format("%s/.e2/lib/e2/templates",
								info.root)

  e2lib.init2() -- configuration must be available

  e2tool.opendebuglogfile(info)

  --XXX create some policy module where the following policy settings
  --XXX and functions reside (server names, paths, etc.)

  -- the '.' server as url
  info.root_server = "file://" .. info.root
  info.root_server_name = "."

  -- the proj_storage server is equivalent to 
  --  info.default_repo_server:info.project-locaton
  info.proj_storage_server_name = "proj-storage"

  -- need to configure the results server in the configuration, named 'results'
  info.result_server_name = "results"

  info.default_repo_server = "projects"
  info.default_files_server = "upstream"

  -- build modes
  info.build_modes = { "tag", "branch" }

  -- the build mode policy used
  info.build_mode = nil

  -- prefix the chroot call with this tool (switch to 32bit on amd64)
  -- XXX not in buildid, as it is filesystem location dependent...
  info.chroot_call_prefix = {}
  info.chroot_call_prefix["x86_32"] = string.format("%s/.e2/bin/e2-linux32",
								info.root)
  -- either we are on x86_64 or we are on x86_32 and refuse to work anyway
  -- if x86_64 mode is requested.
  info.chroot_call_prefix["x86_64"] = ""

  -- build number state file
  info.buildnumber_file = string.format("%s/.e2/build-numbers", info.root)

  -- build number table
  info.build_numbers  = {}

  -- checksum file suffixes, ordered by priority
  info.default_checksum_file_suffix = ".sha1"

  info.sources = {}

  -- read project environment file
  local p2 = info.root .. "/proj/env"
  local function invalid_access(table, k, v)
    e2lib.abort("attempt to add an entry `", k, "' with value '",
		v, "' to the project environment table, the environment",
		" may not be extended once it is loaded.")
  end
  info.env = {}
  if e2util.exists(p2) then
    e2lib.log(3, "loading " .. p2)
    local function check(k, v)
      local t = type(v)
      if t ~= "string" and t ~= "number" then
	e2lib.abort("invalid environment value for `", k,
		    "' in proj/env, value must be a string or number")
      end
    end
    local lua_should_have_localrec
    local env = function(tab) 
		  if type(tab) == "string" then
		    local path2 = info.root .. "/" .. tab
		    e2lib.log(3, "loading " .. path2)
		    e2lib.dofile_protected(path2, { env=lua_should_have_localrec, e2env = info.env })
		  elseif type(tab) == "table" then
		    for k, v in pairs(tab) do -- for each result...
		      if type(k) ~= "string" then
			e2lib.abort("invalid environment key `", k, 
				    "' in proj/env, key must be a string")
		      end
		      local t = type(v)
		      if t == "table" then
			table.foreach(v, check)
		      else 
			check(k, v)
		      end
		    end
		    -- *** we go again through the table - can this be fused?
		    for k, v in pairs(tab) do
		      local t = info.env[ k ]
		      if not t then t = {} end
		      if type(v) == "table" then
			for k2, v2 in pairs(v) do
			  t[ k2 ] = v2
			end
		      else
			t = v
		      end
		      info.env[ k ] = t
-- 		      print("info.env[", k, "]:", t)
-- 		      if type(t) == "table" then
-- 			table.foreach(t, print)
-- 		      end
-- 		      print("info.env:")
-- 		      table.foreach(info.env, print)
		    end
		  else
		    e2lib.abort("invalid argument to `env' - should be string or table")
		  end
		end
    lua_should_have_localrec = env
    local rc, re = e2lib.dofile_protected(p2, { env = env, e2env = info.env })
    if not rc then
      return false, e:cat(re)
    end
    -- do not set this metatable here, as we want to allow changing 
    -- the environment in a hook...
    --setmetatable(info.env, { __newindex = invalid_access })
  end

  -- read project configuration
  local rc, re = e2tool.load_user_config(info, info.root .. "/proj/config",
						info, "project", "e2project")
  if not rc then
    return false, e:cat(re)
  end
  info.project[".fix"] = nil
  local e = new_error("in project configuration:")
  if not info.project.release_id then
    e:append("key is not set: release_id")
  end
  if not info.project.name then
    e:append("key is not set: name")
  end
  if type(info.project.default_results) ~= "table" then
    e2lib.warnf("WDEFAULT", "in project configuration:")
    e2lib.warnf("WDEFAULT", 
		" default_results ist not a table. Defaulting to empty list.")
  end
  if not info.project.chroot_arch then
    e2lib.warnf("WDEFAULT", "in project configuration:")
    e2lib.warnf("WDEFAULT", " chroot_arch defaults to x86_32")
    info.project.chroot_arch = "x86_32"
  end
  if not info.chroot_call_prefix[info.project.chroot_arch] then
    e:append("chroot_arch is set to an invalid value")
  end
  if info.project.chroot_arch == "x86_64" and
     e2lib.host_system_arch ~= "x86_64" then
    e:append("running on x86_32: switching to x86_64 mode is impossible.")
  end
  if e:getcount() > 1 then
    return false, e
  end
  info.release_id = info.project.release_id
  info.name = info.project.name
  info.default_results = info.project.default_results

  local function add_builtin_servers(info)
    local function add_server(info, name, url, cachable)
      e2lib.warnf("WDEFAULT", "setting up builtin server:")
      e2lib.warnf("WDEFAULT", " %s [%s]", name, url)
      local s = {}
      s.name = name
      s.url = url
      s.cachable = cachable
      if info.servers[name] then
        return false, new_error(
			"cannot setup builtin server %s: server exists", name)
      end
      info.servers[name] = s
      return true, nil
    end
    local rc, re
    rc, re = add_server(info, info.root_server_name, info.root_server, false)
    if not rc then
      return false, re
    end
    info.servers[info.root_server_name].writeback = true
    if not info.servers[info.default_repo_server] then
      e2lib.warnf(WPOLICY, "server %s is unconfigured.", 
						info.default_repo_server)
      e2lib.warnf(WPOLICY, "Cannot setup server %s",
						info.proj_storage_server_name)
      -- do not treat that as an error, unless the server is used.
      return true, nil
    end
    -- create the new url
    local proj_storage_server = string.format("%s/%s",
	     info.servers[info.default_repo_server].url, info.project_location)
    rc, re = add_server(info, info.proj_storage_server_name,
						proj_storage_server, true)
    if not rc then
      return false, re
    end
    return true, nil
  end

  -- chroot config
  info.chroot_config_file = "proj/chroot"
  rc, re = e2tool.read_chroot_config(info)
  if not rc then
    return false, e:cat(re)
  end
  
  -- licences
  rc, re = e2tool.load_user_config(info, info.root .. "/proj/licences",
					info, "licences", "e2licence")
  if not rc then
    return false, e:cat(re)
  end
  info.licences[".fix"] = nil
  -- privide sorted list of licences
  info.licences_sorted = {}
  for l,lic in pairs(info.licences) do
    table.insert(info.licences_sorted, l)
  end
  table.sort(info.licences_sorted)

  rc, re = e2tool.load_source_config(info)
  if not rc then 
    return false, e:cat(re)
  end

  rc, re = e2tool.load_result_config(info)
  if not rc then
    return false, e:cat(re)
  end

  -- servers
  info.server_default_config = {     -- default values
    cachable = true,
  }

  -- read .e2/proj-location
  info.project_location_config = string.format("%s/.e2/project-location", 
								info.root)
  local line, re = e2lib.read_line(info.project_location_config)
  if not line then
    return false, e:cat(re)
  end
  local s, e, l = string.find(line, "^%s*(%S+)%s*$")
  if not l then
    return false, e:append("%s: can't parse project location",
					info.project_location_config)
  end
  info.project_location = l
  e2lib.log(4, string.format("project location is %s", info.project_location))
  local config = e2lib.get_global_config()
  info.servers = config.servers
  if not info.servers then
    return false, e:append("no servers configured in global configuration")
  end
  local rc, re = add_builtin_servers(info)
  if not rc then
    return false, e:cat(re)
  end
  info.servers[".fix"] = nil
  for name, server in pairs(info.servers) do
    server.name = name
    -- apply default values
    for k, v in pairs(info.server_default_config) do
      if server[k] == nil then
        server[k] = info.server_default_config[k]
      end
    end
    -- print for debugging purposes
    for k, v in pairs(server) do
      v = tostring(v)
      e2lib.log(4, string.format("%-20s: %-10s %s", name, k, v))
    end
  end

  -- warn if deprecated config files still exist
  local deprecated_files = {
	"proj/servers",
	"proj/result-storage",
	"proj/default-results",
	"proj/name",
	"proj/release-id",
  }
  for _,f in ipairs(deprecated_files) do
    local path = string.format("%s/%s", info.root, f)
    if e2util.exists(path) then
      e2lib.warnf("WDEPRECATED", "File exists but is no longer used: `%s'", f)
    end
  end

  local cache_url
  if config.cache and config.cache.path then
    -- replace %u by the username, %l by the project location
    local replace = { u=e2lib.username, l=info.project_location }
    local cache_path = e2lib.format_replace(config.cache.path, replace)
    cache_url = string.format("file://%s", cache_path)
  else
    cache_url = string.format("%s/cache", info.root_server)
    e2lib.warnf("WPOLICY", "cache defaulting to %s", cache_url)
  end
  info.cache, re = e2lib.setup_cache("local cache", cache_url, info.servers)
  if not info.cache then
    return false, e:cat(re)
  end

  --e2tool.add_source_results(info)

  -- provide a sorted list of results
  info.results_sorted = {}
  for r,res in pairs(info.results) do
    table.insert(info.results_sorted, r)
  end
  table.sort(info.results_sorted)

  -- provided sorted list of sources
  info.sources_sorted = {}
  for s,src in pairs(info.sources) do
    table.insert(info.sources_sorted, s)
  end
  table.sort(info.sources_sorted)

  -- provide sorted list of servers
  info.servers_sorted = {}
  for s, srv in pairs(info.servers) do
    table.insert(info.servers_sorted, s)
  end
  table.sort(info.servers_sorted)

  rc, re = policy.init(info)
  if not rc then
    return false, e:cat(re)
  end
  return info, nil
end

--
--   e2tool.check_project_info(INFO, ALL, [ACCESS, [VERBOSE]]) -> BOOLEAN
--
--     Checks project information for consistancy
--     When ALL is false, check only those results/sources reachable from
--       the dependency list
--     When ACCESS is true, checks also server locations
--     When VERBOSE is true, sends error messages to stderr

function e2tool.check_project_info(info, all, access, verbose)
  local rc, re
  local e = new_error("error in project configuration")
  rc, re = e2tool.check_chroot_config(info)
  if not rc then
    return false, e:cat(re)
  end
  local rc, re = e2tool.check_sources(info)
  if not rc then
    return false, e:cat(re)
  end
  local rc, re = e2tool.check_results(info)
  if not rc then
    return false, e:cat(re)
  end
  local rc, re = e2tool.check_licences(info)
  if not rc then
    return false, e:cat(re)
  end
  local rc = e2tool.dsort(info)
  if not rc then
    return false, e:cat("cyclic dependencies")
  end
  return true, nil
end


-- Save user configuration file
--
--   e2tool.save_user_config(PATH, CFG)
--
--      Save a partial project configuration (source or result)
--      into a file named PATH
--      CFG is one of info.sources[s], info.results[r], info.chroot,
--      info.licences
--
--   e2tool.config_create(CONFIGTYPE) -> CGF
--
--      Create and return an empty configuration.
--      CONFIGTYPE is one of "e2source", "e2result", "e2chroot",
--      "e2licence".
--
--   e2tool.config_insert(CFG, KEY, VALUE)
--
--      Add a new field to a source/result configuration entry.

function e2tool.save_user_config(path, entry)
  local function save_field(file, indent, key, value, ender)
    file:write(ender .. "\n" .. string.rep("  ", indent))
    if type(key) ~= "number" then file:write(key .. " = ") end
    if type(value) == "string" then
      file:write("\"" .. value .. "\"")
    elseif type(value) == "number" or type(value) == "boolean" then
      file:write(tostring(value))
    elseif type(value) == "table" then
      local e = "{"
      for k, v in pairs(value) do
	save_field(file, indent+1, k, v, e)
	e = ","
      end
      if e == "," then
	file:write("\n" .. string.rep("  ", indent) .. "}")
      else
	file:write("{}")
      end
    else
      e2lib.bomb("unexpected data type in info field entry: "
	.. type(value) .. " at " .. key)
    end
  end
  local x = entry[".fix"]
  if not x then e2lib.abort("fixature missing: " .. path) end
  local f, msg = io.open(path, "w")
  if not f then e2lib.abort("cannot write config " .. path .. ":" .. msg) end
  f:write("-- config   -*- Lua -*-\n\n")
  f:write(x[".e2"] .. " ")
  local e = "{"
  for _, k in ipairs(x) do
    save_field(f, 1, k, entry[k], e)
    e = ","
  end
  f:write("\n}\n")
  f:close()
end

function e2tool.config_create(configtype)
  if configtype ~= "e2source" and
     configtype ~= "e2result" and
     configtype ~= "e2chroot" and
     configtype ~= "e2licence" then
    e2lib.abort("unknown configuration type: " .. configtype)
  end
  local f = {}
  f[".e2"] = configtype
  local c = {}
  c[".fix"] = f
  return c
end

function e2tool.config_insert(entry, key, value)
  local k = key or (#entry + 1)
  entry[k] = value
  table.insert(entry[".fix"], k)
end

-- Debugging tools
--
--   e2tool.show_project_info(INFO)
--
--     Performs a simple dump of the project information in INFO.

function e2tool.show_project_info(info)
  print("name:", info.name)
  print("root:", info.root)
  print("results: ", info.servers[result_server_name].url)
  print("\nsources:")
  for i, src in pairs(info.sources) do
    print()
    for k, v in pairs(src) do
      if k == "file" then
        for f, t in pairs(v) do
          print("", k, t.server, t.name)
        end
      else
        print("", k, v)
      end
    end
  end
  print("\nresults:")
  for i, res in pairs(info.results) do
    print()
    for k, v in pairs(res) do
      print("", k, v)
      if type(v) == "table" and k ~= ".fix" then
        for u, b in pairs(v) do
          print("", "", u, b)
        end
      end
    end
  end
  print("\nservers:")
  for i, srv in pairs(info.servers) do
    print("", srv.name, srv.url)
  end
  print("\ndefault results:")
  for k, v in pairs(info.default_results) do
    print("", v)
  end
end


-- Dependency management
--
--   e2tool.dsort(INFO) -> ARRAY
--
--     Returns an array with the names of all results of the project specified
--     by INFO, topologically sorted according to the projects dependency
--     information.
--
--   e2tool.dlist(INFO, RESULT) -> ARRAY
--
--     Returns a sorted array with all dependencies for the given RESULT in the
--     project specified by INFO, the RESULT itself excluded.
--
--   e2tool.dlist_recursive(INFO, RESULT) -> ARRAY
--
--     Similar to e2tool.dlist(), but also includes indirect dependencies.
--     If RESULT is a table, calculate dependencies for all elements, inclusive,
--     otherwise calculate dependencies for RESULT, exclusive.

function e2tool.dlist(info, res)
  local t = info.results[res] and info.results[res].depends or {}
  table.sort(t)
  return t
end

function e2tool.dlist_recursive(info, result)
  local had = {}
  local path = {}
  local col = {}
  local t = {}
  local function visit(res)
    if had[res] then
      e2lib.warn("WOTHER", "cyclic dependency: " .. table.concat(path, " "))
      t = nil
    elseif t and not col[res] then
      table.insert(path, res)
      had[res] = true
      col[res] = true
      for _, d in ipairs(e2tool.dlist(info, res)) do visit(d) end
      if t then table.insert(t, res) end
      had[res] = nil
      path[#path] = nil
    end
  end
  for _, r in ipairs(
	type(result) == "table" and result or e2tool.dlist(info, result)) do
    visit(r)
  end
  return t
end

function e2tool.dsort(info)
  return e2tool.dlist_recursive(info, info.default_results)
end


-- Server handling
--
--   e2tool.lookup_server(INFO, SRV) -> ABSOLUTE_PATH, BOOLEAN
--
--     For a given project internal server name, returns its absolute path
--     and true if the server is the project directory itself, false otherwise
--
--   e2tool.find_server(INFO, PATH) -> SERVERNAME, RELATIVE_PATH
--
--     Return servername and relative path for given PATH or nil.

function e2tool.lookup_server(info, srv)
  e2lib.log(1, "e2tool.lookup_server() is deprecated")
  local path, e = cache.file_path(info.cache, srv, "", {})
  if not path then
    e2lib.abort(e)
    return nil
  end
  return path
end

--- e2tool.valid_server
-- @param info info data
-- @param srv string: server name
-- @return true if the server is valid, false otherwise
function e2tool.valid_server(info, srv)
  if info.servers[srv] then
    return true
  end
  return false
end

function e2tool.find_server(info, path)
  e2lib.log(1, "e2tool.find_server() is deprecated and may not work") 
  -- XXX find all callers and replace with something else
  if #path > 0 then
    local statf
    local s = e2util.realpath(info.root)
    if s then
      statf = e2util.stat(s)
      if statf and statf.type == "directory" and "/" ~= string.sub(s, -1) then
	s = s .. "/"
      end
    end
    local p = e2util.realpath(path)
    if p then
      statf = e2util.stat(p)
      if statf and statf.type == "directory" and "/" ~= string.sub(p, -1) then
	p = p .. "/"
      end
      if #p >= #s + 2 and s == string.sub(p, 1, #s) then
	return ".", string.sub(p, #s + 1)
      end
      for k, v in pairs(info.servers) do
	if string.match(v.path, ":") then
	  return path, ""
	end
	s = e2util.realpath(v.path)
	if #p >= #s + 2 and s == string.sub(p, 1, #s) then
	  return k, string.sub(p, #s + 2)
	end
      end
    end
  end
  return nil
end


-- Retrieval of files information
--
--   e2tool.expanded_files_list(INFO, SOURCE)
--
--     For the given source of type file, calculate the absolute pathname of
--     the file, expand directories to the files it contains. The resulting
--     list is cached to INFO.sources.*.flist and returned, with the
--     absolute filename as key and the value telling whether it is local.

function e2tool.read_hash_file(info, server, location)
  local e = new_error("error reading hash file")
  local cs = nil
  local cache_flags = { cache = true }
  local rc, re = cache.cache_file(info.cache, server, location, cache_flags)
  if not rc then
    return nil, e:cat(re)
  end
  local path = cache.file_path(info.cache, server, location, cache_flags)
  if path then
    cs = e2lib.read_line(path)
    if cs then
      return cs, nil
    end
  end
  return nil, e:append("can't open checksum file")
end

--- hash a file
-- @param path string: path to a file
-- @return string the hash value, nil on error
-- @return nil, an error string on error
function e2tool.hash_path(path)
  e2lib.log(4, string.format("hashing %s", path))
  local f = io.popen(string.format("sha1sum %s", path), "r")
  if not f then
    return false, "can't calculation checksum"
  end
  local l = f:read("*l")
  f:close()
  if not l then
    return nil, "can't calculation checksum"
  end
  local s, e, cs, b = string.find(l, "^(%S+)%s+(%S+)$")
  if not cs then
    return nil, "can't calculation checksum"
  end
  return cs
end

--- hash a file addressed by server name and location
-- @param info info structure
-- @param server the server name
-- @param location file location relative to the server
-- @return string the hash value, nil on error
-- @return nil, an error string on error
function e2tool.hash_file(info, server, location)
  local e = new_error("error hashing file")
  local cache_flags = { cache = true }
  local rc, re = cache.cache_file(info.cache, server, location, cache_flags)
  if not rc then
    return nil, e:cat(re)
  end
  local path, re = cache.file_path(info.cache, server, location, cache_flags)
  if not path then
    return nil, e:cat(re)
  end
  return e2tool.hash_path(path)
end

function e2tool.expanded_files_list(info, source)
  e2lib.log(4, "expanded_files_list: " .. source)

  local function add_to_files_list(info, flist, file)
    e2lib.log(4, "add_to_files_list: " .. file.name)
    local rserv, islocal = e2tool.lookup_server(info, file.server)
    if not rserv then e2lib.abort("cannot resolve server: " .. file.server) end
    local absol = rserv .. "/" .. file.name
    local dir, base, ftyp = e2lib.splitpath(absol)
    if not dir then
      e2lib.abort(base .. ": " .. file.name)
    end
    if ftyp ~= "regular" then
      e2lib.abort("is not a regular file: " .. file.name)
    end
    local t = {}
    for k, v in pairs(file) do t[k] = v end
    t.absol = absol
    t.islocal = islocal
    t.base = base
    table.insert(flist, t)
  end
  local s = info.sources[source]
  if s.flist then return s.flist end
  if not s.file then return nil end
  s.flist = {}
  for _, t in ipairs(s.file) do
    add_to_files_list(info, s.flist, t)
  end
  for _,f in pairs(s.flist) do
    e2lib.log(4, "expanded_files_list: s.flist[x].absol: " .. f.absol)
  end
  return s.flist
end

function e2tool.projid(info)
	if info.projid then
		return info.projid
	end
	-- catch proj/init/*
	local hc = hash.hash_start()
	for f in e2lib.directory(info.root .. "/proj/init") do
		if not e2lib.is_backup_file(f) then
			local location = string.format("proj/init/%s", 
							e2lib.basename(f))
			local hash, e = e2tool.hash_file(info,
					info.root_server_name, location)
			if not hash then
				e2lib.abort(e)
			end
			hc:hash_line(location)		-- the filename
			hc:hash_line(hash)	-- the file content
		end
	end
	for f in e2lib.directory(info.root .. "/proj/hooks", false, true) do
		if not e2lib.is_backup_file(f) then
			local location = string.format("proj/hooks/%s", 
							e2lib.basename(f))
			local hash, e = e2tool.hash_file(info,
					info.root_server_name, location)
			if not hash then
				e2lib.abort(e)
			end
			hc:hash_line(location)	-- the file location
			hc:hash_line(hash)	-- the file content
		end
	end
	hc:hash_line(info.release_id)
	hc:hash_line(info.project.chroot_arch)
	hc:hash_line(buildconfig.VERSION)
	info.projid = hc:hash_finish()
	return info.projid
end

-- Check if e2 is in a fixed tag
--
--   e2tool.e2_has_fixed_tag(info)
--
--     return true if e2 is at fixed tag, and false if not.

function e2tool.e2_has_fixed_tag(info)
  local v = e2lib.parse_e2versionfile(info.root .. "/.e2/e2version")
  e2lib.log(2, "Checking for fixed e2 tag.")
  if v.tag == "^" then
    e2lib.log(1, "Fatal: e2 is not at a fixed tag.")
    return false
  end
  return true
end

-- Check if a tag exists on the e2 tool repository
--
--   e2tool.e2_tag_exists(tag)
--
--     return true if the tag exists and false if not.

function e2tool.e2_tag_exists(tag)
  local rc = e2scm["git"].tag_available(tag, nil)
  if rc then
    e2lib.log(1, "Fatal: Tag exists in the local repository. FIXME")
    return true
  end
  return false
end

-- Check if there are sources which are "on pseudo tags"
--
--   e2tool.has_pseudotags(info)
--
--     Return true if there is at least one source on a pseudo
--     tag.

function e2tool.has_pseudotags(info)
  local rc=false
  local l={}
  e2lib.log(2, "Checking for pseudo tagged sources.")
  for _,s in pairs(info.sources) do
    if s.tag and s.tag == "^" then
      e2lib.log(1, "Fatal: source " .. s.name .. " has pseudo tag.")
      rc=true
      table.insert(l, s.name)
    end
  end
  return rc, l
end

-- Check if tags are available for all sources
--
--   e2tool.tag_available(info, check_local, check_remote)
--
--     Return true if the tags are available, false if not.
--     Choose local and remote checking by setting check_local and 
--     check_remote.
--
--     TODO: works with the null project. Use and/or write scm specific 
--     code to make it usable for projects that use non-git scms.

function e2tool.tag_available(info, check_local, check_remote)
  local missing_local = {}
  local missing_remote = {}
  local rc = true
  --*** this code is basically broken and git-version specific
  e2lib.log(2, "Checking for tag availability.")
  for _,s in pairs(info.sources) do
    if s.tag and check_local then
      local cmd = "GIT_DIR=in/" .. s.name
		.. "/.git git rev-list --max-count=1 refs/tags/"
		.. s.tag .. " --"
      rc = e2lib.callcmd_capture(cmd)
      if rc ~= 0 then
        e2lib.log(1, "Fatal: source " .. s.name 
		.. ": local tag not available: " .. s.tag)
	rc = false
      end
    end
    if s.tag and check_remote then
      local cmd = "GIT_DIR=" .. e2tool.lookup_server(info, s.server) .. "/" 
		.. s.remote
		.. " git rev-list --max-count=1 refs/tags/"
		.. s.tag .. " --"
      rc = e2lib.callcmd_capture(cmd)
      if rc ~= 0 then
        e2lib.log(1, "Fatal: " .. s.name .. ": remote tag not available: " 
		.. s.tag)
	rc = false
      end
    end
  end
end

-- Do all checks required before tagging a project
--
--   e2tool.pre_tag_check(info, check_local, check_remote)
--
--     Return true if all checks succeed and false if not.
--     For offline usage local and remote checking can be turned on 
--     as needed.

function e2tool.pre_tag_check(info, tag, check_local, check_remote)
  -- do all checks first
  local e2_has_fixed_tag_flag, has_pseudotags_flag, has_pseudotags_list
  local tag_unavailable_flag, e2_tag_exists_flag
  e2_has_fixed_tag_flag = e2tool.e2_has_fixed_tag(info)
  has_pseudotags_flag, has_pseudotags_list = e2tool.has_pseudotags(info)
  tag_unavailable_flag = e2tool.tag_available(info, check_local, check_remote)
  if tag then
    e2_tag_exists_flag = e2tool.e2_tag_exists(tag)
  else
    e2_tag_exists_flag = false
  end

  -- return false if any fatal errors occured
  if not e2_has_fixed_tag_flag or 
     has_pseudotags_flag or 
     tag_unavailable_flag or
     e2_tag_exists_flag then
    return false
  end
  return true
end

--- calculate sourceids for all sources
-- @param info
-- @param sourceset
-- @return bool
-- @return an error object on failure
function e2tool.calc_sourceids(info, sourceset)
	local e = new_error("calculating sourceids failed")
	for _,src in pairs(info.sources) do
		local sourceid, re = scm.sourceid(info, src.name, sourceset)
		if not sourceid then
			e:cat(re)
		end
	end
	if e.getcount() > 1 then
		return false, e
	end
	return true, nil
end

--- calculate licence id
-- @param info
-- @param licence
-- @return string
-- @return an error object on failure
function e2tool.licenceid(info, licence)
	local rc, re
	local e = new_error("calculating licence id failed for licence: %s",
								licence)
	local lic = info.licences[licence]
	if lic.licenceid then
		return lic.licenceid
	end
	local hc = hash.hash_start()
	hc:hash_line(licence)			-- licence name
	hc:hash_line(lic.server)		-- server name
	for _,file in ipairs(lic.files) do
		local h, re = e2tool.hash_file(info, lic.server, file)
                if not h then
			return nil, e:cat(re)
                end
		hc:hash_line(file)		-- licence file name
		hc:hash_line(h)			-- licence file content
	end
	lic.licenceid, re = hc:hash_finish()
	if not lic.licenceid then
		return nil, e:cat(re)
	end
	return lic.licenceid
end

--- calculate licenceids for all licences
-- @param info
-- @return bool
-- @return an error object on failure
function e2tool.calc_licenceids(info)
	local e = new_error("calculating licenceids failed")
	for l,_ in pairs(info.licences) do
		local licenceid, re = e2tool.licenceid(info, l)
		if not licenceid then
			e:cat(re)
		end
	end
	if e.getcount() > 1 then
		return false, e
	end
	return true, nil
end

--- return the first eight digits of buildid hash
-- @param buildid string: hash value
-- @return string: a short representation of the hash value
function e2tool.bid_display(buildid)
	return string.format("%s...", string.sub(buildid, 1, 8))
end

--- get the buildid for a result, calculating it if required
-- XXX this function always succeeds or aborts
-- @param info
-- @param resultname
-- @param mode
-- @return the buildid
function e2tool.buildid(info, resultname)
	e2lib.log(4, string.format("get buildid for %s", resultname))
	local r = info.results[resultname]
	local id, e = e2tool.pbuildid(info, resultname)
	if not id then
		e2lib.abort(e)
	end
	local hc = hash.hash_start()
	hc:hash_line(r.buildno)
	hc:hash_line(r.pbuildid)
	r.buildid = hc:hash_finish()
	return r.build_mode.buildid(r.buildid)
end

--- get the pbuildid for a result, calculating it if required
-- XXX this function always succeeds or aborts
-- @param info
-- @param resultname
-- @return the buildid
function e2tool.pbuildid(info, resultname)
	e2lib.log(4, string.format("get pbuildid for %s", resultname))
	local e = new_error("calculating result id failed")
	local r = info.results[resultname]
	if r.pbuildid then
		return r.build_mode.buildid(r.pbuildid)
	end
	local hc = hash.hash_start()
	for _,s in ipairs(r.sources) do
		local src = info.sources[s]
		local source_set = r.build_mode.source_set()
		local sourceid, re = 
				scm.sourceid(info, s, source_set)
		if not sourceid then
			return nil, e:cat(re)
		end
		hash.hash_line(hc, s)			-- source name
		hash.hash_line(hc, sourceid)		-- sourceid
	end
	for _,d in ipairs(r.depends) do
		hash.hash_line(hc, d)			-- dependency name
	end
	for _,c in ipairs(r.collect_project_results) do
		hash.hash_line(hc, c)		-- name
	end
	for _,s in ipairs(r.collect_project_sources) do
		hash.hash_line(hc, s)		-- name
	end
	for _,g in ipairs(r.collect_project_chroot_groups) do
		hash.hash_line(hc, g)		-- name
	end
	for _,l in ipairs(r.collect_project_licences) do
		hash.hash_line(hc, l)		-- name
		-- We collect all licences. So we cannot be sure to catch
		-- them via results/sources. Include them explicitly here.
		local lid, re = e2tool.licenceid(info, l)
		if not lid then
			return nil, e:cat(re)
		end
		hash.hash_line(hc, lid)		-- licence id
	end
	local groupid = e2tool.chrootgroupid(info, "base")
	hc:hash_line(groupid)
	if r.chroot then
		for _,g in ipairs(r.chroot) do
			local groupid = e2tool.chrootgroupid(info, g)
			hash.hash_line(hc, g)
			hash.hash_line(hc, groupid)
		end
	end
	r.envid = e2tool.envid(info, resultname)
	hc:hash_line(r.envid)
	if not r.pseudo_result then
		local location = e2tool.resultbuildscript(info.results[resultname].directory)
		local hash, re = e2tool.hash_file(info,info.root_server_name, 
								location)
		if not hash then
			return nil, e:cat(re)
		end	
		hc:hash_line(hash)			-- build script hash
	end
	e2lib.log(4, string.format("hash data for resultid %s\n%s",
							resultname, hc.data))
	r.resultid = hash.hash_finish(hc)	-- result id (without deps)

	hc = hash.hash_start()
	local projid = e2tool.projid(info)
	hc:hash_line(projid)		-- project id
	hash.hash_line(hc, r.resultid)	-- result id
	for _,d in ipairs(r.depends) do
		local id = e2tool.pbuildid(info, d)
		hash.hash_line(hc, id)		-- buildid of dependency
	end
	for _,c in ipairs(r.collect_project_results) do
		local res = info.results[c]
					-- pbuildids of collected results
		hash.hash_line(hc, e2tool.pbuildid(info, c))
	end
	e2lib.log(4, string.format("hash data for resultid %s\n%s", 
							resultname, hc.data))
	r.pbuildid = hash.hash_finish(hc)	-- buildid (with deps)
	return r.build_mode.buildid(r.pbuildid)
end

--- calculate the buildids for all results
-- @param info
-- @return nothing
function e2tool.calc_buildids(info)
	e2lib.logf(3, "calculating buildids")
	for _,r in ipairs(info.results) do
		local bid, pbid
		bid = e2tool.buildid(info, r)
		pbid = e2tool.pbuildid(info, r)
		e2lib.logf(3, "result %20s: pbid(%s) bid(%s)",
			r, e2tool.bid_display(pbid), e2tool.bid_display(bid))
	end
end

function e2tool.flush_buildids(info)
	for r, res in pairs(info.results) do
		res.buildid = nil
		res.pbuildid = nil
	end
end

function e2tool.chrootgroupid(info, groupname)
	local g = info.chroot.groups_byname[groupname]
	if g.groupid then
		return g.groupid
	end
	local hc = hash.hash_start()
	hc:hash_line(g.name)
	hc:hash_line(g.server)
	for _,f in ipairs(g.files) do
		hc:hash_line(f)
		-- XXX  hash each file?
	end
	e2lib.log(4, string.format("hash data for chroot group %s\n%s", 
							groupname, hc.data))
	g.groupid = hc:hash_finish()
	return g.groupid
end

function e2tool.calc_chrootids(info)
	for _,grp in pairs(info.chroot.groups) do
		e2tool.chrootgroupid(info, grp.name)
	end
end

--return a table of environment variables valid for a result
-- @param info the info table
-- @param resultname string: name of a result
-- @return table: environment variables valid for the result
function e2tool.env_by_result(info, resultname)
	local e = {}
	-- take global variables first
	for k,v in pairs(info.env) do
		if type(v) == "string" or
		   type(v) == "number" then
			e[k] = v
		end
	end
	-- result specific variables override global ones
	for k,v in pairs(info.env) do
		if type(v) == "table" and
		   k == resultname then
			for k1,v1 in pairs(v) do
				e[k1] = v1
			end
		end
	end
	return e
end

--- envid: calculate a value represennting the environment for a result
-- @param info the info table
-- @param resultname string: name of a result
-- @return string: envid value
function e2tool.envid(info, resultname)
	local e = e2tool.env_by_result(info, resultname)
	local hc = hash.hash_start()
	for k,v in pairs(e) do
		hc:hash_line(string.format("%s=%s", k, v))
	end
	local envid = hc:hash_finish()
	return envid
end

function e2tool.add_source_result(info, sourcename, source_set)
	e2lib.log(3, string.format("adding source result for source %s", 
								sourcename))
	local src = info.sources[sourcename]
	local r = {}
	r.name = string.format("src-%s", src.name)
	r.sources = { src.name }
	r.depends = {}
	r.chroot = {}
	r.chroot.groups = {}
	r.pseudo_result = true
	info.results[r.name] = r
end

function e2tool.add_source_results(info, source_set)
	e2lib.log(4, "add source results")
	for _, src in pairs(info.sources) do
		e2tool.add_source_result(info, src.name)
	end
end

function e2tool.check_source(info, sourcename)
	local src = info.sources[sourcename]
	local rc, e, re
	if not src then
		e = new_error("no source by that name: %s", sourcename)
		return false, e
	end
	local e = new_error("in source: %s", sourcename)
	if not src.type then
		e2lib.warnf("WDEFAULT", "in source %s", sourcename)
		e2lib.warnf("WDEFAULT", " type attribute defaults to `files'")
		src.type = "files"
	end
	if not e2scm[src.type] then
		e:append("unknown scm type: %s", src.type)
		return false, e
	end
	rc, re = scm.validate_source(info, sourcename)
	if not rc then
		return false, re
	end
	return true, nil
end

function e2tool.check_sources(info)
	local e = new_error("Error while checking sources")
	local rc, re
	for n,s in pairs(info.sources) do
		rc, re = e2tool.check_source(info, n)
		if not rc then
			e:cat(re)
		end
	end
	if e:getcount() > 1 then
		return false, e
	end
	return true, nil
end

function e2tool.check_licence(info, l)
	local e = new_error("in licence: %s", l)
	local lic = info.licences[l]
	if not lic.server then
		e:append("no server attribute")
	end
	if not lic.files then
		e:append("no files attribute")
	elseif not type(lic.files) == "table" then
		e:append("files attribute is not a table")
	else
		for _,file in ipairs(lic.files) do
			if not type(file) == "string" then
				e:append("file list holds non-string element")
			end
		end
	end
	if e:getcount() > 1 then
		return false, e
	end
	return true
end

function e2tool.check_licences(info)
	local e = new_error("Error while checking licences")
	local rc, re
	for l, lic in pairs(info.licences) do
		rc, re = e2tool.check_licence(info, l)
		if not rc then
			e:cat(re)
		end
	end
	if e:getcount() > 1 then
		return false, e
	end
	return true, nil
end

function e2tool.check_workingcopies(info)
	local e = new_error("Error while checking working copies")
	local rc, re
	for n,s in pairs(info.sources) do
		rc, re = scm.check_workingcopy(info, n)
		if not rc then
			return false, e:cat(re)
		end
	end
	if e:getcount() > 1 then
		return false, e
	end
	return true, nil
end

function e2tool.check_results(info)
	local e = new_error("Error while checking results")
	local rc, re
	for r,_ in pairs(info.results) do
		rc, re = e2tool.check_result(info, r)
		if not rc then
			e:cat(re)
		end
	end
	if e:getcount() > 1 then
		return false, e
	end
	for r,_ in pairs(info.results) do
		rc, re = e2tool.check_collect_project(info, r)
		if not rc then
			e:cat(re)
		end
	end
	if e:getcount() > 1 then
		return false, e
	end
	return true, nil
end

--- check result configuration
-- @param info table: the info table
-- @param resultname string: the result to check
function e2tool.check_result(info, resultname)
	local res = info.results[resultname]
	local e = new_error("in result %s:", resultname)
	if not res then
		e:append("result does not exist: %s", resultname)
		return false, e
	end
	if res.files then
		e2lib.warnf("WDEPRECATED", "in result %s", resultname)
		e2lib.warnf("WDEPRECATED", 
			" files attribute is deprecated and no longer used")
		res.files = nil
	end
	if type(res.sources) == "nil" then
		e2lib.warnf("WDEFAULT", "in result %s:", resultname)
		e2lib.warnf("WDEFAULT", " sources attribute not configured." ..
				"Defaulting to empty list")
		res.sources = {}
	elseif type(res.sources) == "string" then
		e2lib.warnf("WDEPRECATED", "in result %s:", resultname)
		e2lib.warnf("WDEPRECATED", " sources attribute is string. "..
				"Converting to list")
		res.sources = { res.sources }
	end
	if type(res.sources) ~= "table" then
		e:append("sources attribute has wrong type")
	end
	for i,s in ipairs(res.sources) do
		if type(i) ~= "number" then
			e:append("invalid key in sources list")
		end
		if type(s) ~= "string" then
			e:append("non-string element in sources list")
		elseif not info.sources[s] then
			e:append("source does not exist: %s", s)
		end
	end
	if type(res.depends) == "nil" then
		e2lib.warn("WDEFAULT", "in result %s: ", resultname)
		e2lib.warn("WDEFAULT", " depends attribute not configured. " ..
				"Defaulting to empty list")
		res.depends = {}
	elseif type(res.depends) == "string" then
		e2lib.warnf("WDEPRECATED", "in result %s:", resultname)
		e2lib.warnf("WDEPRECATED", " depends attribute is string. "..
				"Converting to list")
		res.depends = { res.depends }
	end
	if type(res.depends) ~= "table" then
		e:append("depends attribute has wrong type")
	end
	for i,d in pairs(res.depends) do
		if type(i) ~= "number" then
			e:append("non-number key in depends list")
		end
		if type(d) ~= "string" then
			e:append("non-string element in depends list")
		elseif not info.results[d] then
			e:append("dependency does not exist: %s", d)
		end
	end
	if type(res.chroot) == "nil" then
		e2lib.warnf("WDEFAULT", "in result %s:", resultname)
		e2lib.warnf("WDEFAULT", " chroot groups not configured. " ..
				"Defaulting to empty list")
		res.chroot = {}
	elseif type(res.chroot) == "string" then
		e2lib.warnf("WDEPRECATED", "in result %s:", resultname)
		e2lib.warnf("WDEPRECATED", " chroot attribute is string. "..
				"Converting to list")
		res.chroot = { res.chroot }
	end
	if type(res.chroot) ~= "table" then
		e:append("chroot attribute has wrong type")
	end
	-- apply default chroot groups
	for _,g in ipairs(info.chroot.default_groups) do
		table.insert(res.chroot, g)
	end
	for i,g in pairs(res.chroot) do
		if type(i) ~= "number" then
			e:append("non-number key in chroot list")
		end
		if type(g) ~= "string" then
			e:append("non-string element in chroot list")
		elseif not info.chroot.groups_byname[g] then
			e:append("chroot group does not exist: %s", g)
		end
	end
	if not res.buildno then
		res.bn = {}
		res.buildno = "0"
	end
	local build_script = string.format("%s/%s", info.root,
		e2tool.resultbuildscript(info.results[resultname].directory))
	if not e2lib.isfile(build_script) then
		e:append("build-script does not exist: %s", build_script)
	end
	-- stop if we had an error, as the collect_project stuff depends
	-- on a sane result structure
	if e:getcount() > 1 then
		return false, e
	end
	return true, nil
end

--- check collect_project configuration
-- This function depends on sane result and source configurations.
-- Run only after check_result() was run on all results.
-- @param info table: the info table
-- @param resultname string: the result to check
function e2tool.check_collect_project(info, resultname)
	local res = info.results[resultname]
	local e = new_error("in result %s:", resultname)
	if not res.collect_project then
		-- insert empty tables, to avoid some conditionals in the code
		res.collect_project_results = {}
		res.collect_project_sources = {}
		res.collect_project_chroot_groups = {}
		res.collect_project_licences = {}
		-- XXX store list of used chroot groups here, too, and use.
		return true, nil
	end
	local d = res.collect_project_default_result
	if not d then
		e:append("collect_project_default_result is not set")
	elseif type(d) ~= "string" then
		e:append(
			"collect_project_default_result is non-string")
	elseif not info.results[d] then
		e:append("collect_project_default_result is set to "..
			 "an invalid result: %s", d)
	end
	-- catch errors upon this point before starting additional checks.
	if e:getcount() > 1 then
		return false, e
	end
	res.collect_project_results = e2tool.dlist_recursive(info,
				res.collect_project_default_result)
	-- store a sorted list of required results
	table.insert(res.collect_project_results,
			res.collect_project_default_result)
	table.sort(res.collect_project_results)
	e2lib.warnf("WDEFAULT", "collect_project takes these results: %s",
		table.concat(res.collect_project_results, ","))
	-- store a sorted list of required sources, chroot groups and licences
	local tmp_grp = {}
	local tmp_src = {}
	tmp_grp["base"] = true
	for _,r in ipairs(res.collect_project_results) do
		local res = info.results[r]
		for _,s in ipairs(res.sources) do
			tmp_src[s] = true
		end
		for _,g in ipairs(res.chroot) do
			-- use the name as key here, to hide duplicates...
			tmp_grp[g] = true
		end
	end
	res.collect_project_sources = {}
	for s,_ in pairs(tmp_src) do
		-- and build the desired array
		table.insert(res.collect_project_sources, s)
	end
	table.sort(res.collect_project_sources)
	res.collect_project_chroot_groups = {}
	for g,_ in pairs(tmp_grp) do
		table.insert(res.collect_project_chroot_groups, g)
	end
	table.sort(res.collect_project_chroot_groups)
	res.collect_project_licences = {}
	for _,l in ipairs(info.licences_sorted) do
		table.insert(res.collect_project_licences, l)
	end
	table.sort(res.collect_project_licences)
	if e:getcount() > 1 then
		return false, e
	end
	return true, nil
end

--- parse build numbers from a string and store to the build number table
-- @param info: the info table
-- @param s string: the string to parse
-- @param build_numbers table: build number table (optional)
-- @return bool
-- @return nil, an error object on error
function e2tool.string2bn(info, s, build_numbers)
	e2lib.logf(4, "string2bn()")
	if not build_numbers then
		build_numbers = info.build_numbers
	end
	local rc
	local re = new_error("error parsing build numbers:")
	e2lib.log(3, "parsing build numbers")
	local line = 0
	for l in s:gmatch("[^\n]+") do
		line = line + 1
		local bn = {}
		local r
		r, bn.bid, bn.status, bn.num = l:match(
			("([-%w_]+)%s+(%x+)%s+(%S+)%s+(%d+)"))
		if not r then
			re:append("parse error in line %d", line)
			return false, re
		end
		e2lib.logf(4, "%s %s %s %s", r, bn.bid, bn.status, bn.num)
		local oldbn = build_numbers[r]
		if oldbn and oldbn.num and oldbn.num ~= bn.num then
			bn.oldnum = oldbn.num
		end
		build_numbers[r] = bn
	end
	return true, nil
end

--- serialize the build number table suitable for storage or network
-- transport
-- @param info: the info table
-- @param build_numbers table: build number table (optional)
-- @return s string: serialized build numbers, or nil
-- @return nil, an error object on error
function bn2string(info, build_numbers)
	e2lib.logf(4, "bn2string()")
	if not build_numbers then
		build_numbers = info.build_numbers
	end
	local s = ""
	for r,bn in pairs(build_numbers) do
		e2lib.logf(4, "%s %s %s %s", r, bn.bid, bn.status, bn.num)
		local s1 = string.format("%s %s %s %s\n",
					r, bn.bid, bn.status, bn.num)
		s = s .. s1
	end
	return s, nil
end

--- write the build number file
-- @param info the info table
-- @param file string: the build number file (optional)
-- @param build_numbers table: build number table (optional)
-- @return bool
-- @return an error object on error
function e2tool.buildnumber_write(info, file, build_numbers)
	e2lib.logf(4, "e2tool.buildnumber_write()")
	local rc, msg
	if not file then
		file = info.buildnumber_file
	end
	if not build_numbers then
		build_numbers = info.build_numbers
	end
	local e = new_error("error writing build number file:")
	e2lib.logf(3, "writing build numbers to %s", file)
	local s, re = bn2string(info)
	if not s then
		e:cat(re)
		return false, e
	end
	rc, re = e2lib.write_file(file, s)
	if not rc then
		e:cat(re)
		return false, e
	end
	return true, nil
end

--- read the build number file into the buildnumber table
-- @param info the info table
-- @param file string: the build number file (optional)
-- @param build_numbers table: build number table (optional)
-- @return bool
-- @return an error object on error
function e2tool.buildnumber_read(info, file, build_numbers)
	e2lib.logf(4, "e2tool.buildnumber_read()")
	local rc, re, msg
	if not file then
		file = info.buildnumber_file
	end
	if not build_numbers then
		build_numbers = info.build_numbers
	end
	local e = new_error("error reading build number file:")
	e2lib.logf(3, "reading build-numbers from %s", file)
	local s, re = e2lib.read_file(file)
	if not s and e2lib.isfile(file) then
		e:cat(re)
		return false, e
	elseif not s then
		e2lib.warnf("WOTHER", "build number file does not exist")
		s = ""
	end
	local rc, re = e2tool.string2bn(info, s, build_numbers)
	if not rc then
		e:cat(re)
		return false, e
	end
	return true, nil
end

--- merge build numbers from the build number table to the results
-- @param info table: the info table
-- @return bool
-- @return nil, an error object on failure
function e2tool.buildnumber_mergetoresults(info)
	e2lib.log(3, string.format("merging build numbers to results"))
	local e = new_error("merging build numbers to results:")
	for r, res in pairs(info.results) do
		local bn = info.build_numbers[r]
		if not bn then
			e2lib.warnf("WOTHER",
				"no build number entry for result: %s", r)
		elseif res.pbuildid == bn.id then
			e2lib.log(3, string.format(
				"applying build number to result: %s [%s]",
				r, bn.num))
			res.buildno = bn.num
		else
			e:append("pseudo buildid mismatch in result %s", r)
		end
	end
	if e:getcount() > 1 then
		return false, e
	end
	return true, nil
end

--- merge build numbers and pbid from the result to the build number table
-- @param info table: the info table
-- @return bool
-- @return nil, an error object on failure
function e2tool.buildnumber_mergefromresults(info)
	e2lib.log(3, string.format("merging build numbers from results"))
	for r, res in pairs(info.results) do
		local bn = info.build_numbers[r]
		if not bn then
			e2lib.warnf("WOTHER", 
			   "creating new build number entry for result: %s", r)
			-- create a new entry
			bn = {}
			bn.status = "ok"
			bn.num = res.buildno
			info.build_numbers[r] = bn
		end
		bn.bid = e2tool.pbuildid(info, r)
		e2lib.logf(4, "%s %s %s %s", r, tostring(bn.bid), bn.status, bn.num)
	end
	return true, nil
end

--- display buildnumbers
-- @param build_numbers table: build number table
-- @param loglevel (optional, default 2)
-- @return nil
function e2tool.buildnumber_display(build_numbers, loglevel)
	if not loglevel then
		loglevel = 2
	end
	e2lib.log(loglevel, "displaying build-number table:")
	e2lib.logf(loglevel, "%-20s %-40s %2s %5s %-7s",
			"result", "pbuildid", "st", "num", "old")
	for r,bn in pairs(build_numbers) do
		local changed = ""
		if bn.oldnum then
			changed = string.format("[%d]", bn.oldnum)
		end
		e2lib.logf(loglevel, "%-20s %40s %2s %5d %-7s",
					r, bn.bid, bn.status, bn.num, changed)
	end
end

--- request new build numbers from the server
-- @param info
-- @return bool
-- @return an error object on failure
function e2tool.buildnumber_request(info)
	e2lib.log(3, "requesting build numbers from server")
	local rc, re
	local e = new_error("error requesting build numbers")
	local tmpdir = e2lib.mktempdir()
	local tmpreq = string.format("%s/build-number.req.tmp", tmpdir)
	local tmpres = string.format("%s/build-number.res.tmp", tmpdir)
	local curlflags = "--create-dirs --silent --show-error --fail"
	local url = string.format(
		"'%s?project=%s&user=%s&host=%s'",
		e2lib.buildnumber_server_url, info.name, e2lib.osenv["USER"],
		e2lib.hostname)
	local args = string.format(
			"%s " ..
			"--header 'Content-type: text/plain' " ..
			"--data-binary '@%s' %s -o %s",
			curlflags,
			tmpreq, url, tmpres)
	rc, re = e2tool.buildnumber_write(info, tmpreq)
	if not rc then
		e:append(re)
		return false, e
	end
	e2lib.log(3, "sending request")
	rc, re = e2lib.curl(args)
	if not rc then
		e:append(re)
		return false, e
	end
	rc, re = e2tool.buildnumber_read(info, tmpres)
	if not rc then
		e:append(re)
		return false, e
	end
	e2lib.rmtempdir(tmpdir)
	return true, nil
end

--- perform the buildnumber update without synchronizing to the server
-- @param info
-- @return bool
-- @return an error object on failure
function e2tool.buildnumber_request_local(info)
	e2lib.log(3, "requesting build numbers locally")
	local rc, re
	local req  -- the request
	local sta  -- the state
	local res  -- the response
	local e = new_error("error in local buildnumber request")
	-- compose the request
	req = info.build_numbers
	-- compose the state
	sta = {}
	rc, re = e2tool.buildnumber_read(info, nil, sta)
	if not rc then
		return false, e:cat(re)
	end
	-- run the update function locally
	res = {}
	rc, re = e2tool.buildnumber_update(sta, req, res)
	if not rc then
		return false, e:cat(re)
	end
	-- convert the result to a string
	local s
	s, re = bn2string(info, res)
	if not s then
		return false, e:cat(re)
	end
	-- convert the string back into the info structure
	rc, re = e2tool.string2bn(info, s)
	if not rc then
		return false, e:cat(re)
	end
	return true
end

--- update buildnumbers - usable on server side, or in --no-sync mode on the
-- client side
-- @param state table: build number table state
-- @param request table: build number table request
-- @param response table: build number table response
-- @return build number table
function e2tool.buildnumber_update(state, request, response)
	e2lib.log(4, "buildnumber_update()")
	e2lib.log(4, "state:")
	e2tool.buildnumber_display(state, 4)
	e2lib.log(4, "request")
	e2tool.buildnumber_display(request, 4)
	for r,bn in pairs(request) do
		local req = bn
		local sta = state[r]
		e2lib.logf(4, "checking status for %s", r)
		if not sta then
			sta = {}
			sta.bid = req.bid
			sta.num = 1
			sta.status = "ok"
			state[r] = sta
		elseif sta.bid ~= req.bid or sta.num ~= req.num then
			e2lib.logf(4, "increasing buildnumber for %s", r)
			-- update status
			sta.num = math.max(sta.num, req.num) + 1
			sta.bid = req.bid
			sta.status = "ok"
		end
		-- create the response
		local res = {}
		res.bid = sta.bid
		res.num = sta.num
		res.status = sta.status
		response[r] = res
	end
	return true, nil
end

--- select the result and apply build options
-- @param info
-- @param r string: the result name
-- @param force_rebuild bool
-- @param request_buildno bool
-- @param keep_chroot bool
-- @param build_mode table: build mode policy
-- @param playground bool
-- @return nil
function e2tool.select_result(info, r, force_rebuild, request_buildno,							keep_chroot, build_mode, playground)
	local res = info.results[r]
	if not res then
		e2lib.abort(string.format("selecting invalid result: %s", r))
	end
	res.selected = true
	res.force_rebuild = force_rebuild
	res.request_buildno = request_buildno
	res.keep_chroot = keep_chroot
	if build_mode then
		res.build_mode = build_mode
	end
	res.playground = playground
end


--- select results based upon a list of results usually given on the 
-- command line. Parameters are assigned to all selected results.
-- @param info the info structure
-- @param results table: list of result names
-- @param force_rebuild bool
-- @param request_buildno bool
-- @param keep_chroot bool
-- @param build_mode table: build mode policy. Optional.
-- @param playground bool
-- @return bool
-- @return an error object on failure
function e2tool.select_results(info, results, force_rebuild, request_buildno, keep_chroot, build_mode, playground)
	for _,r in ipairs(results) do
		e2tool.select_result(info, r, force_rebuild, request_buildno,
					keep_chroot, build_mode, playground)
	end
	return true, nil
end

--- print selection status for a list of results
-- @param info
-- @param results table: list of result names
-- @return bool
-- @return an error object on failure
function e2tool.print_selection(info, results)
	for _,r in ipairs(results) do
		local e = new_error("error printing selected results")
		local res = info.results[r]
		if not res then
			return false, e:append("no such result: %s", r)
		end
		local s = res.selected and "[ selected ]" or 
					   "[dependency]"
		local f = res.force_rebuild and "[force rebuild]" or ""
		local b = res.request_buildno and "[request buildno]" or ""
		local p = res.playground and "[playground]" or ""
		e2lib.log(3, string.format(
					"Selected result: %-20s %s %s %s %s",
								r, s, f, b, p))
	end
	return true, nil
end

--- chdir to a directory relative to info.root
-- @param info
-- @param dir string: directory
-- @return bool
-- @return an error object on failure
function e2tool.lcd(info, dir)
  local e = new_error("chdir failed")
  local abspath = string.format("%s/%s", info.root, dir)
  local rc, re = e2lib.chdir(abspath)
  if not rc then
    return false, e:cat(re)
  end
  return true
end

--- check for configuration syntax compatibility
-- @param info
-- @return bool
-- @return an error object on failure
function e2tool.display_config_syntax_compat(info)
  local e = new_error("displaying configuration syntax compatibilitly failed")
  for _,m in ipairs(info.config_syntax_compat) do
    print(m)
  end
  return true
end

--- check for configuration syntax compatibility
-- @param info
-- @return bool
-- @return an error object on failure
function e2tool.check_config_syntax_compat(info)
  local e = new_error("checking configuration syntax compatibilitly failed")
  local l, re = e2lib.read_line(info.config_syntax_file)
  if not l then
    return false, e:cat(re)
  end
  for _,m in ipairs(info.config_syntax_compat) do
    m = string.format("^%s$", m)
    if l:match(m) then
      return true, nil
    end
  end
  return false, e:append("configuration syntax mismatch")
end

--- read chroot configuration
-- @param info
-- @return bool
-- @return an error object on failure
function e2tool.read_chroot_config(info)
  local e = new_error("reading chroot config failed")
  local t = {}
  local rc, re = e2tool.load_user_config(info, info.chroot_config_file,
						t, "chroot", "e2chroot")
  if not rc then
    return false, e:cat(re)
  end
  if type(t.chroot) ~= "table" then
    return false, e:append("chroot configuration table not available")
  end
  if type(t.chroot.groups) ~= "table" then
    return false, e:append("chroot.groups configuration is not a table")
  end
  if type(t.chroot.default_groups) ~= "table" then
    return false, e:append("chroot.default_groups is not a table")
  end
  --- chroot config
  -- @class table
  -- @name info.chroot
  -- @field default_groups chroot groups used in any result
  -- @field groups chroot groups in configuration order
  -- @field groups_byname chroot groups keyed by name
  -- @field groups_sorted chroot groups sorted by name
  info.chroot = {}
  info.chroot.default_groups = t.chroot.default_groups
  info.chroot.groups = t.chroot.groups
  info.chroot.groups_byname = {}
  info.chroot.groups_sorted = {}
  for _,grp in pairs(info.chroot.groups) do
    if grp.group then
      e:append("in group: %s", grp.group)
      e:append(" `group' attribute is deprecated. Replace by `name'")
      return false, e
    end
    if not grp.name then
      return false, e:append("`name' attribute is missing in a group")
    end
    local g = grp.name
    table.insert(info.chroot.groups_sorted, g)
    if info.chroot.groups_byname[g] then
      return false, e:append("duplicate chroot group name: %s", g)
    end
    info.chroot.groups_byname[g] = grp
  end
  table.sort(info.chroot.groups_sorted)
  return true
end

--- check chroot config
-- @param chroot
-- @return bool
-- @return an error object on failure
function e2tool.check_chroot_config(info)
  local e = new_error("error validating chroot configuration")
  for g,grp in pairs(info.chroot.groups) do
    if not grp.server then
      e:append("in group: %s", grp.name)
      e:append(" `server' attribute missing")
    elseif not info.servers[grp.server] then
      e:append("in group: %s", grp.name)
      e:append(" no such server: %s", grp.server)
    end
    if (not grp.files) or (#grp.files) == 0 then
      e:append("in group: %s", grp.name)
      e:append(" list of files is empty")
    else
      for _,l in ipairs(grp.files) do
        if type(l) ~= "string" then
          e:append("in group: %s", grp.name)
          e:append(" file list contains non-string element")
        end
      end
    end
  end
  if (not info.chroot.default_groups) or #info.chroot.default_groups == 0 then
    e:append(" `default_groups' attribute is missing or empty list")
  else
    for _,g in ipairs(info.chroot.default_groups) do
      if not info.chroot.groups_byname[g] then
        e:append(" unknown group in default groups list: %s", g)
      end
    end
  end
  if e:getcount() > 1 then
    return false, e
  end
  return true
end

local function gather_result_paths(info, basedir, results)
  results = results or {}
  for dir in e2lib.directory(info.root .. "/" .. e2tool.resultdir(basedir)) do
    local tmp
    if basedir then
      tmp = basedir .. "/" .. dir
    else
      tmp = dir
    end
    if e2util.exists(e2tool.resultconfig(tmp)) then
      table.insert(results, tmp)
    else
      --try subfolder
      gather_result_paths(info,tmp, results)
    end
  end
  return results
end


local function gather_source_paths(info, basedir, sources)
  sources = sources or {}
  for dir in e2lib.directory(info.root .. "/" .. e2tool.sourcedir(basedir)) do
    local tmp
    if basedir then
      tmp = basedir .. "/" .. dir
    else
      tmp = dir
    end
    if e2util.exists(e2tool.sourceconfig(tmp)) then
      table.insert(sources, tmp)
    else
      --try subfolder
      gather_source_paths(info,tmp, sources)
    end
  end
  return sources
end

-- checks for valid characters in str
local function checkFilenameInvalidCharacters(str)
  if not str:match("^[-_0-9a-zA-Z/]+$") then
    return false
  else
    return true
  end
end

-- replaces all slashed in str with dots
local function slashToDot(str)
  return string.gsub(str,"/",".",100)
end

function e2tool.load_source_config(info)
  local e = new_error("error loading source configuration")
  info.sources = {}

  for _,src in ipairs(gather_source_paths(info)) do
    local list, re
    local path = e2tool.sourceconfig(src)
    local types = { "e2source", }

    if not checkFilenameInvalidCharacters(src) then
        e:append("invalid source file name: %s")
        e:append("only digits, alphabetic characters, and `-', `_' and `/' "..
	 	"are allowed")
        return false, e
    end

    list, re = e2tool.load_user_config2(info, path, types)
    if not list then
      return false, e:cat(re)
    end


    for _,item in ipairs(list) do
      local name = item.data.name

      if not name and #list == 1 then
	e2lib.warnf("WDEFAULT", "`name' attribute missing in source config.")
	e2lib.warnf("WDEFAULT", " Defaulting to directory name")
        item.data.directory = src
        item.data.name = slashToDot(src)
        name = slashToDot(src)
      end

      if not name then
	return false, e:append("`name' attribute missing in source config")
      end

      if not name:match("^[-_0-9a-zA-Z.]+$") then
        e:append("invalid source name: %s")
        e:append("only digits, alphabetic characters, and `-', `_' and `.' "..
	 	"are allowed")
        return false, e
      end

      if info.sources[name] then
        return false, e:append("duplicate source: %s", name)
      end

      item.data.configfile = item.filename
      info.sources[name] = item.data
    end
  end
  return true, nil
end

function e2tool.load_result_config(info)
  local e = new_error("error loading result configuration")
  info.results = {}

  for _,res in ipairs(gather_result_paths(info)) do
    local list, re
    local path = e2tool.resultconfig(res)
    local types = { "e2result", }

    if not checkFilenameInvalidCharacters(res) then
        e:append("invalid result file name: %s")
        e:append("only digits, alphabetic characters, and `-', `_' and `/' "..
	 	"are allowed")
        return false, e
    end

    list, re = e2tool.load_user_config2(info, path, types)
    if not list then
      return false, e:cat(re)
    end
    if #list ~= 1 then
      return false, e:append("only one result allowed per config file")
    end
    for _,item in ipairs(list) do
      local name = item.data.name
      item.data.directory = res

      if name and name ~= res then
        e:append("`name' attribute does not match configuration path")
	return false, e
      end

      item.data.name = slashToDot(res)
      name = slashToDot(res)

      if not name:match("^[-_0-9a-zA-Z.]+$") then
        e:append("invalid result name: %s",name)
        e:append("only digits, alphabetic characters, and `-', `_' and `.' "..
	 	"are allowed")
        return false, e
      end

      if info.results[name] then
        return false, e:append("duplicate result: %s", name)
      end

      item.data.configfile = item.filename
      info.results[name] = item.data
    end
  end
  return true, nil
end

--- set umask to value used for build processes
-- @param info 
function e2tool.set_umask(info)
  e2lib.logf(4, "setting umask to %04o", info.chroot_umask)
  e2util.umask(info.chroot_umask)
end

-- set umask back to the value used on the host
-- @param info
function e2tool.reset_umask(info)
  e2lib.logf(4, "setting umask to %04o", info.host_umask)
  e2util.umask(info.host_umask)
end

-- initialize the umask set/reset mechanism (i.e. store the host umask)
-- @param info
function e2tool.init_umask(info)
  -- save the umask value we run with
  info.host_umask = e2util.umask(022);
  -- restore the previous umask value again
  e2util.umask(info.host_umask);
end

-- assemble a path from parts
-- the returned string is created from the input parameters like
-- "base[/str][/postfix]"
local function generatePath(base, str, postfix)
  if str then
    base = base .. "/" .. str
  end
  if postfix then
    base = base .. "/" .. postfix
  end
  return base
end
    
-- get directory for a result
-- Returns the path to the resultdir and the optional postfix is appended
-- with a slash (e.g. res/name/build-script)
-- @param result name optional
-- @param optional postfix for the direcory
-- @return path of the result
function e2tool.resultdir(name, postfix)
  return generatePath("res",name,postfix)
end

-- get directory for a source
-- Returns the path to the sourcedir and the optional postfix is appended
-- with a slash (e.g. src/name/config)
-- @param source name optional
-- @param optional postfix for the direcory
-- @return path of the source
function e2tool.sourcedir(name, postfix)
  return generatePath("src",name,postfix)
end

-- get path to the result config
-- @param resultname
-- @return path to the resultconfig
function e2tool.resultconfig(name)
  return e2tool.resultdir(name,"config")
end

-- get path to the result build-script
-- @param resultname
-- @return path to the result build-script
function e2tool.resultbuildscript(name)
  return e2tool.resultdir(name,"build-script")
end

--- get path to the source config
-- @param sourcename
-- @return path to the sourceconfig
function e2tool.sourceconfig(name)
  return e2tool.sourcedir(name,"config")
end
